#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

// Alphabet used only contains CAPPS letters
const char ALPHABET[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
const int ALPHABET_SIZE = 26;

// Define constants and variables
char CIPHERTEXT[] = "PIDVNCQGUFMNIKYEZSDFCICPAEKPHAFRPIMXXKCFTGAQHPMVRXCZGCEWZLGLOXUPGLYCKAPEWWLKQPEXUIAWYCSMMLXVJDWGTAJGSWHWGLMDPKJMCLAMDVGURPYEEJTHNHWCNABTSXRFMRMLPUXEVYRTYHLXIKYSYQHGPICLDQFGGKCGKAQGJWNCGYCTQKSJJWYVUTPEDZVMEZJTVRRPREBEGWBJCPALQDWUVWQAHQPKQZURODYPKMVQSTDEHSWZOYIEKBVRREMNFEJSXJQSTDEHSWZOYIETPKJMCLACKTGBVWNAUJXFQROMRDYSGNJOYGMTDHXIWKGDKEGMVILUEUFMNVNCTUDWSBRNTAPEIGMRCQUMQAVNZCKAEUHKJYKQTAHXSNICYDAHTABZOZAZKBGDKTMDUQTDNTQLTAKPZRJVMRUQSGNCGDAZJTVDDDMFUDVAWUQOUQUASNICQUMQDXRDFCAXWJECVONOVQCWWYWKAZYBSUHWCRUQBSRJQSVUHPKBLCQMQDIAARUCLQICSXGCPAHQBVNIGNEFYGZNTVMREUFMNIGQCADISALOYHUIIGAZCAOZJPSCLCCNMEPKMFUMUFHDKVRUCUZQDLNEJMNQDWMVRJGSFEGAJXGKIMEAWJFBGNTEUGRVPRAAGJWNCGREHUPAMVKYDQLXSSRTNEXQPXAZEYPMHPWWTQLTDQGSBLCFIEJDJRRGJEQCQSATQSNQIISJMGLTGHPSLFONAZXPVXGGJOEITMBROGGAIOSVSCYZQRGSNRNRAKQDZRGQNOFQBGMVEGDUHPEORBCREUPWBKTYDMDDHAFRPIATXSYRTRIDQBVNCWYNPQTSWUCPAYJDVXFFGAMJTKJZTCMPQGWBVTTAMEPFXZVCCQHUAIVTYMGCPHJLUYNMCPFQRFMDUQHWPLKLTQVDJJDCAODTPVXJRMRGCQSALNFOQDHMAUGAEPEGGBKTCSMCXYXJCAHMHPEZLGYSEKPKLRDCCMIXSVVZNLATXJZLCLDATTJNGGLTQLXJJDWKAZYBSUROYRQBDUXDWKPQIRGLFGLODCTWVRPAHMIRSBKCLHMIRGVFPYSGQHSERPYNMEWSEZCKUUJPNJIKCDMTTVNRPGMMYHWUVULAAIPTRROMQGUTJJVUREQIIJJEJMAZYBSUFCJTMOPIDVPYOQHPEDZVMCAHPBXJQOUQHXSMRTKEUQKGUKCNODGJWCVOGAQIIWJEKKAXSDEYVUAOOEAGWXQMHQSIGAHWCEEJPNJTQKVADISMVFCPMHIAARCTEZJJJJWQGAAUCUXEVPOPUHLNRPGMMBDRJDDYSQWJAJFFCPQHIGNLONOGSDEJZUJOZWTWBKCTAAQALJPCMLMUJKXLJCCFEGWNJVCSEQDGBDGSSMCXYXJBYMNQTSUKCWAABPVRJUCABUFMNECXENHPGURUSSEKGJXLQFIBEEGCROMOXQTMLYCKOYUTGUZCYPDUHWWKQSSQEPFRDCJQGUIAYFFCAZYBSUVURUZQDWBLOJEMECWVLOYZQRGSNUGAEDJTRJHWCNMETKDDJGPAFDLJDQCFMSXDNLUMUGCPYRICDAZQDENUKEAYGJWEFECSZKCUJKKLHMCKABKQSMMWXJJWCCXOBPEXLGJAZQDFJEQQSMIPNJECLAAXPYRICDAETXKBVQFEOJDJNGGLABEGIDVEMMADDKBFNMNSEEWBTQAOBESWVFUTEDJJVXFSSEBQHKJRPMSEQKGUKCKEECDLDUQNEDWJFCFWMZMCQSBZOKEECDLDUQPEEFDFMVWYEABXSLFOKUUJDGAXWJHAITNNJOCSYEIMMFRMDQICGBUKXEDEFMNWGXACKTDNSCPUXXDLJFCJTAGJWXLXGMAIWSYFWAOEYBUXDECRFUOSNFDYRGBWGMVWKCACQGRFQOUQUJELFOZOUEEWAXWLTAKDSUKCWAOKGAXJQSMOEBTXZQCUYQBSZLKLACKTSWUCKUUJDJJGKBOQGJWEFUNOPUAWERTYTQQDXRDFMMGDSGJWKPMAKPWXCKYEOEBGNHWCFMPTEXJRYRMEPHJEJYRBUGYDEVMUAXTUCFTCABUCSBEGAEEIPJRFUYLFQGDJGCPAPUCLAFRYRMUCLARTCDQFDABJCJTMHESARUYIDUEGMVUKOEJGSAEQQOOQBAWYQOUQTTNNDQQSQWJAAJGDALVPNXIRCRSKCLXLQXAYRPLXUQYNUCPVXTQKCQHIWIRGNRQSXKXZTCMPYGWLRQYONQDTJDCQCGYSSMFEMMAIWGVVPQEEJPTNDOSIFEDTAZIYDAHTKYFPBEDQBGBKTCSMCXYXJFCPAYHWUVUYFMIISAROQEPQTGUZCQESKXFMFQAAYYCZXZPBIOQSGYFTCSFQFMJEFMCTUVSAROYONQDTJWKAADQBEDZVMIYFGWBJKMNMTDKYVNMTMCPFQFFYQGUASVRSSIZQTEJCQSVUHPEXSCPUXXDKDSKPAYFPJJUGLTDESGLFOZOUEDKCIGQAYYVGBVURAHQBWWTCLTMTDKLFOYQGUASVRSSIZQTFPICAAPQDSUKCWAMJTWBSQAOGKBKXITGSAUAWBGCQSMHPEYVNYNMCXTRRQLDQUCUXEVPADQBMVIKLOOUGGWKGQEYSWAOIGCLQSWSVRXYSQZXEKFQHIYRDUXEVMUCKTMVXTSPATTZXDGLSAJXFQRTYPFQSGNCJCTUDWSLFTRAPEDKNLEFIRHTWUVHCLUPBWWKGCSOQEGDDCQOEITMBGCGSZQDUXEUCGGYGSVVUAABQGUXDGJEAXTUCFTMZMCQSNFCJTMOPXRTCPAYCJACFVPIEJTKZLCLDAEJNRICKATYHLXIKYDAZXEKFGNEDWJFCRTYMXXTUXDQCRMCTKBVUFOYUCKNGQPQGUGSIRQCRMCISXDCSSQBTKLFPTIPQGSVFLMVQCGAWFECRADIWJAWLTMHHWJVNCSBQGSLFPRIZKPJNDCYVQDIMARFCPAYHVJECKINYPXRQGPAYKBSNJEYLMDPSOIKAAPEHMUUGQCQHPEMFEMMNEXGYRTYEEJXUJIGKAEFTJWRUYNPQGSVRVCEZSDFCICPUYWGMYFEMMYKXLXJCLIYQXKNWQPAYVPDJIEMMQBTKNJVCSMDXEJZUCRMCIGMFUCXUBPVXJQQQGQIJXROGGAISWLZFGRMCESBJCPAZEXLNTQKEXUHWXLXGRMIHMJJJGSFEGAJJWKAECPABZPREDUHKJEVCSPEFMNFWRRMICWBJGERGFDZJMKYUYWDJRCCOUQJXFQRGQCMFPVXUQHADTXEIFQJOSYRGNHWCTUDWSMVKVAPEIGMRCQUMVPERCKYPMHPLARUMQGUTMVACPDUCOGXCQEIOEEWAXWLTAKDSUKCWAGCYSAUKKZAEAGPZEMEGCAMPRTMNPUDKQFOCNEDDKOVEFAYFPJJHWCOGJGGBYQKEZICGBMGLHMCKWADCQIEIDWQFTPIHUAWGTNYMAKDZRGQNOFQBGYFTOUQVPRNDKQTADPGBVQSVUKCWWYWKADUHHXJVYPAHFMNEKLGGUBKJSKYADQOSXUGNOUISWXLXGRYKXLJJJGSFEGAJJFGFQHTFCVUMHQSIGAVQQSQKHSVZIMSPUHUJEUYRMCCSVRPFAEUVMREVCAZTPJJDOSIFETSXWKKDQQAYDDVCMBETDNJVGVQHPEBVFCMMIRGVFPYOOECZNTKYMAFPABGGPGGDISAROYUYWGMYFFCAHUHLALBCSCKPDNICMCMCXFQFOYIESJJCFRYRMUCUXEVPADUBMVRPYSOUCLNUGYGGQTKCRUDODQBFJDGQMMTXJNTCMQGUTDNJGRIHUGSVRICNFYAWIRFCOEWJAJICNOESXFLFOGNGJDKMVEYMUDWSMRGJEEVXFJCOCNFURZNXCPAYQDDXTCJOZTTZJMKYASKPGBHWYTDEPERXQQBQRTJJDGJAHQGSVJGOUMDSGBLDGTMCTFCVQSVUHPEDDCCXBBDKJFCQAHUHLALBCSOEAGLRTYMUCTVRRVYMQDIWJJEYBQSPKWRVCRDQTFZLCLTAEHGDKTMSMDXEJZUYTQHGGAZBYDAIRGAIGPAYEBSRJFCPDUHKJGQQSULTDWFGLTMDIGXAKKBADPGBVOCXUQKSVFUHIYRDVRQKYMAIHWDJCKISEHDNMCLTMJTVNGTCSEQBSBACCRMJPJMVFCMMYHGSZOZOFYCZJGCPTUTDHJICQEYFGWXJJMMQDHWBKCMAOXTYJIQQHACTFBVURAAQRZNXCPGDYISAROROPEHGBRPGMMYHVDICLTQQUMPRQFEOJDJEZTMUMSPTNTCLAPYGWLRQBOEJXJXJGTIGUHKNJJMMQDHVNHWCAQEAAJCJCSFYCZJWCJAPETDNJRYRQSXSVXTYNPUHSEVUQEYFTFJJPCMNYRGVRUAOYFTDXJPYCMRTUJJWZIDQBHJICBEZJGGMVWKAYQFMRECOUQVAMCLCTAZQPYDRGCSOQESARONODFDMLFCMSTEBWWJSSAZTDBJJGCNOECLARXYMQCHWPLTYNOQDKCIGQAYYVGBKKTEDQBLNDRMDQFTJLVDCRAGJWUYGQTUDWSJTCZAPESWJTQLTQSTJCFFMSFYCZJDGQCMFPVXGQPUYJGAIROMRFUTPLVVMOVYBTXFDYROECSEVIMUPKGSWKGYLSKCKMZCQAZJTKMVEFESQGSXHWCNUQUGRRKOUQUAWBMKPAYQRGRJCKAUIBSARXGLTEHSMFOSNPEDCRCKKAZZPJXWKAADQBLJFOYRMLXDQRFMSCKTDQVUTIQHPEJJNYGDYBSBRQQOXXDKMVRMIETTLNIXGSUJPVXLONOGSDGYRKQEPUIWAWGGTADDNXJCKISEHGQVERODGJABIGERQIHSARUSAEQKSWRPYTMBTEJEIMLMFPJJGQBEDSDFCRTROPQHWBKCQAHUCLDICQDQIISEVBROPEHGBRPGMMYHGZLKQEDQBGDMKPFAYPKBZOOUQEWWLKQPSQTTMLFPRAPUFMNECMSQHKAJGCPAZQSSRDKRADEHGDKTMSQGJWNICZEYCTDQFTCSOHTNNICQUMFGGYIKYHUIIGAZC";
double BASELINE_FITNESS;
int ATTEMPTS;
double TETRAFREQUENCIES[456976];

// Function to calculate tetragram frequencies
void calculateFrequencies(const char *text)
{
    int text_length = strlen(text);

    // Initialize the tetrafrequencies array
    for (int i = 0; i < ALPHABET_SIZE * ALPHABET_SIZE * ALPHABET_SIZE * ALPHABET_SIZE; i++)
    {
        TETRAFREQUENCIES[i] = 0.0;
    }

    for (int i = 0; i < text_length - 3; i++)
    {
        int x = (text[i] - 'A') * 26 * 26 * 26 +
                (text[i + 1] - 'A') * 26 * 26 +
                (text[i + 2] - 'A') * 26 +
                (text[i + 3] - 'A');
        TETRAFREQUENCIES[x] += 1;
    }

    for (int i = 0; i < ALPHABET_SIZE * ALPHABET_SIZE * ALPHABET_SIZE * ALPHABET_SIZE; i++)
    {
        TETRAFREQUENCIES[i] /= (text_length - 3);
    }
}
// Function to decrypt ciphertext with a given key
char *decrypt(const char *ciphertext, const char *key)
{
    int ciphertext_length = strlen(ciphertext);
    int key_length = strlen(key);

    char *plaintext = (char *)malloc((ciphertext_length + 1) * sizeof(char));

    if (plaintext == NULL)
    {
        // Handle memory allocation failure
        return NULL;
    }

    for (int i = 0; i < ciphertext_length; i++)
    {
        char letter = ciphertext[i];
        char shift_value = key[i % key_length];

        // Get character alphabet index
        int letter_index = letter - 'A';

        // Get shift value from key value and position
        int shift = shift_value - 'A';

        // Perform inverse shift
        int char_index = (letter_index - shift + 26) % 26;

        // Append the decrypted character to the plaintext
        plaintext[i] = ALPHABET[char_index];
    }

    // Null-terminate the plaintext string
    plaintext[ciphertext_length] = '\0';
    return plaintext;
}

double calculateFitness(const char *text)
{
    int text_length = strlen(text);

    double result = 0.0;

    for (int i = 0; i < text_length - 3; i++)
    {
        char tetragram[5];
        strncpy(tetragram, &text[i], 4);
        tetragram[4] = '\0';

        int x = ((tetragram[0] - 'A') * ALPHABET_SIZE * ALPHABET_SIZE * ALPHABET_SIZE +
                 (tetragram[1] - 'A') * ALPHABET_SIZE * ALPHABET_SIZE +
                 (tetragram[2] - 'A') * ALPHABET_SIZE +
                 (tetragram[3] - 'A'));

        double y = TETRAFREQUENCIES[x];

        if (y == 0.0)
        {
            result += -15.0; // Some large negative number
        }
        else
        {
            result += log(y);
        }
    }

    result = result / (text_length - 3);

    return result;
}

// Function to process a key
void function(const char *key)
{
    char *plain_text_guess = decrypt(CIPHERTEXT, key);
 
    double plain_text_fitness = calculateFitness(plain_text_guess);

    if (BASELINE_FITNESS + 1 > plain_text_fitness && plain_text_fitness > BASELINE_FITNESS - 1)
    {
        printf("%s %lf\n", key, plain_text_fitness);
    }

    // Free dynamically allocated memory for plain_text_guess if necessary
    free(plain_text_guess);
}

// Function to perform brute force attack
void brute_force(int password_length, double baseline_fitness, const char *baseline_text)
{
    BASELINE_FITNESS = baseline_fitness;
    // Calculate baseline frequencies
    calculateFrequencies(baseline_text);



    printf("Number of keys to bruteforce: %f\n", pow(ALPHABET_SIZE, password_length));

    // Create an array to hold the key
    char key[password_length + 1];
    key[password_length] = '\0';

    // Making threadpool with 4 threads

    double totalSize = pow(ALPHABET_SIZE, password_length);

    // Perform brute force
    for (int i = 0; i < pow(ALPHABET_SIZE, password_length); i++)
    {
        // Generate the next key
        int index = i;
        for (int j = 0; j < password_length; j++)
        {
            key[j] = ALPHABET[index % ALPHABET_SIZE];
            index /= ALPHABET_SIZE;
        }


        // Call the function with the key
        function(key);
    } 
    

    return;
}


int main()
{


    // Example usage

    const char *baseLineInpput = "booksInTXT/maias_cleaned.txt"; // Replace with your file path


    // Open the file for reading
    FILE *file = fopen(baseLineInpput, "r");

    if (file == NULL) {
        perror("Error opening the file");
        return 1; // Exit with an error code
    }

    char *baseline_text = NULL;
    size_t buffer_size = 0;

    // Read the file line by line
    size_t characters_read;
    while ((characters_read = getline(&baseline_text, &buffer_size, file)) != -1) {
        // Remove trailing newline character, if present
        if (characters_read > 0 && baseline_text[characters_read - 1] == '\n') {
            baseline_text[characters_read - 1] = '\0';
        }

        // Now 'baseline_text' contains the current line's content
        // You can process or append it as needed
    }

    // Close the file
    fclose(file);


    double baseline_fitness = -9.613269640229246;
    int password_length = 9;
    brute_force( password_length, baseline_fitness, baseline_text); 
 
    return 0;
}
